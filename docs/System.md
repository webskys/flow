# 类型系统

 > 我们为什么和我们怎样要给`Javascript`创建`Flow`

## JavaScript: 好与坏

开发者喜欢使用`Javascript`编写代码，因这它很容易快速上手。这门语言通过使用动态类型的思想有助于快速开发。运行时通过动态编译的思想提供快速迭代的手段。对于一个创造性的程序员，其快速编辑-刷新的周期，身临其境编写代码的体验是非常吸引人的。

然而，改进和增强一个`javascript`代码库是恶名昭彰的挑战。当被打断后开发者就不能快速工作了。他们频繁受到打扰，花费很多时间去调试一些傻瓜式的错误，分析别人编写的库等等。

原则上，这个消耗在基本代码上添加一层类型可以得到缓解，并利用类型信息创建一些工具去解决上面的那些问题。例如，类型可以用来识别漏洞，标记库的接口等等。

在`javascript`（及其相关的语言）里使用类型来管理代码的改进和增强并不新鲜。实际上，近几年己经有几种`Javascript`类型系统诞生了。但是，他们的类型系统的目的不同。一些只考虑可能的错误但不考虑其正确性，另一些保证其静态代码优化的正确性和互操作性，另一个没有得到关注的领域是类型检测其自身的性能。

## Flow: 目标

`Flow`是我们在`Facebook`创建的一个`Javascript`静态类型检查器。随着代码库的改进和增强，`Flow`的主要使命是为`Javascript`开发者提供一个身临其境编写代码的体验--一个快速的编辑-刷新的周期。在设计术语中，我们确定了两个具体的目的：精确和速度,这些目在我们设计实现中无处不在。

### 精确

`JavaScript`的缺陷对`Facebook`有很大的影响，开发者尽可能的找出并修复它们直到投入生产环境。所以我们必须关注其稳定性。同时，我们也关注不会报告太多的虚假错误，因一个较低的信息/噪音比例代表较低的修复比。

换句话说，我们想要`Flow`在实践中分析是精确的，他必须模拟语言的特征，足够准确地理解惯用语和无意错误的区别

精准也有其他令人满意的结果。由于类型是可信赖的原因，开发人员会倾向于依靠他们去构造他们的代码，使用较少的动态检查得到更清洁高效的代码。当类型错误是可信赖的，开发人员可专注于他们的代码而不是考虑来如何重新编写代码来令类型系统通过检查。

### 速度

精确通常是以速度为代价，但是当一个精确分析是满意的，如果我们慢下来编辑-刷新而让开发人员等待我们编译，那么`Javascript`的大多数吸引力就丢失了。

换句话说，我们必须让`Flow`的分析非常快，他必须没有明显延迟地响应代码的改变，虽然在实际中仍不够精确。

与精准一样，速度也有其他显著的效果。当开发人员修改代码时报告了`bugs`，它们就成为了编辑过程的一部分--开发人员不需要运行代码来检测错误，并且跟踪错误代码变得很简单。类似于，在开发人员正在编码时，`IDE`可以显示一个表达式的类型、引用的定义等，我们发现效率明显提高。

### 是什么让`Flow`精确?

路径灵敏性是影响`Flow`精度的主要因素之一:类型与运行时测试交互的方式。许多`Javascript`惯用语的本质是组合特别的运行时值集，并通过简单的、结构化的相等性检查将它们分开。在Flow中，变量可能包含的运行时值集由其类型来描述，对该变量的运行时测试将类型细化为更小的集合。实践证明，这种能力非常强大，而且很普遍。

### 是什么让`Flow`快速?

`Flow`速度的关键模块化：将文件分解为不同大小的块，并在后面把它们组装起来。

幸好，`JavaScript`己经可以把文件作为模板来编写，所以我们请求模板时只需要简单明确的类型特征。（我们仍然推断绝大多数从本地编写到模块中的代码的类型）。巧合的是，开发人员也都认为这是一种好的软件工程实践。

使用模板化，我们可以积极地平行化我们的分析。此外，当文件更改时，我们只需要递增地分析那些依赖此文件的文件。同时，这些选择己经帮助分解规模到数百分行的代码。

在底层，`Flow`依赖于高吞吐量、低延迟的系统基础结构,该基础结构支持在工作者之间并行分配任务，并通过共享内存传达结果。结合文件系统改变后台分析代码库自动更新的架构，`Flow`开发人员在 编辑和重新设置代码后近乎能即时得到反馈，即使在大型存储库中也是如此。