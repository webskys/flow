# 类型与表达式

在`Javascript`中值有许多类型：`numbers`, `strings`, `booleans`, `functions`, `objects`等等。

```javascript
(1234: number);
("hi": string);
(true: boolean);
([1, 2]: Array<number>);
({ prop: "value" }: Object);
(function method() {}: Function);
```

这些值有许多不同的使用方法

```javascript
1 + 2;
"foo" + "bar";
!true;
[1, 2].push(3);
let value = obj.prop;
obj.prop = "value";
method("value");
```

所有这些不同的表达式创建一个新的类型，它是值的类型或在其上运行操作的结果。

```javascript
let num: number = 1 + 2;
let str: string = "foo" + "bar";
```

在`Flow`里第个值和表达式都有一个类型。

## 静态地算出类型

`Flow`需要一种能够算出每种表达式类型的方法。但是它不能运行你的代码来计算，如果它这样做就会受到你代码所有问题的影响。例如，如果你创建一个无限循环`Flow`会一直等待循环完成。

相反，`Flow`靠分析代码算出一个值的类型而不是运行代码来算出（静态分析）。`Flow`以自己的方式处理己知的类型，并且开始去算出所有相关表达式的结果。

例如，算出下面表达式的结果，`Flow`需要首先算出它的值是什么。

```javascript
val1 + val2;
```

如果值是数字，表达式结果属于`number`。如果值是字符串，表达式结果属性`String`。这里有许多不同的可能性，所以`Flow`必须要查找这些值是什么。

如果`Flow`不能为算出每个值的精准类型，那么`Flow`必须算出每个可能的可能的类型，并且检测相关代码是否能够处理所有这些可能的类型。

## 健全与完整

当你运行你的代码时，单个表达式只允许运行有限的值集。但是`Flow`仍然要检测每个可能的值。以这种方式，`Flow`检查了太多的东西，对于有效的代码或者有过分。

通过检测每个可能的值，`Flow`可能会捕获代码在运行时实际不会发生的错误，`Flow`这样做是为了`健全`

在类型系统中，`健全性`是一个类型检测器捕获运行时可能发生每个单独错误的能力。这样做的代价是，有时捕获在运行时不会实际发生的错误

另一方面，`完整性`是一个类型检测器仅捕获在运行时发生的错误的能力。这样做的代价是，有时会丢失在运行时发生的错误。

在理想的情况下，每个类型检查器都是健全的，并且是完整的，因此它捕获运行时发生的每个错误。

`Flow`尽可能地做到健全和完整，但是因为`Javascript`并不是围绕类型系统设计，所以`Flow`有时不得不做出权衡，这种情况发生时，`Flow`倾向于支持`健全性`而不是`完整性`，确保代码没有任何`bug`。

只要`Flow`不会发出太多`噪音`和影响你工作效率，`健全性`就很好。有时，当`健全性`太多的防碍了你，`Flow`则将倾向于`完整性`，只有少数情况下`Flow`会这样做。

其他类型系统则倾向于`完整性`,只报告真实的错误，而倾向于遗漏可能的错误。单元/集成测试是这种方法的极端形式，通常，这样做的代价是遗漏最复杂的错误，让开发人员自己去查找。






